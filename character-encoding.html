<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
body
{
  font-family: arial, sans-serif;
  max-width: 6.75in;
  margin: 0px auto;
  font-size: 85%;
}
 ins  {background-color: #CCFFCC; text-decoration: none;}
 del  {background-color: #FFCACA; text-decoration: none;}
 pre  {background-color: #D7EEFF; font-size: 95%; font-family: "courier new", courier, serif;}
 code {font-family: "courier new", courier, serif;}
 table {font-size: 90%;}
</style>
<title>Character encoding</title>
</head>

<body>

<h2>String Encoding</h2>
<h3>2.13.3 Character literals [lex.ccon]</h3>
<p><sup>2</sup> A character literal that does not begin with <code>u8</code>, 
<code>u</code>, <code>U</code>, or 
<code>L</code> is an <i>ordinary character literal</i>. An ordinary character literal that contains 
a single <i>c-char</i> representable in the execution character set has type 
<code>char</code>, with 
value equal to the numerical value of the encoding of the <i>c-char</i> in the 
execution character set. An ordinary character literal that contains more than 
one <i>c-char</i> is a <i>multicharacter</i> literal. A multicharacter literal, 
or an ordinary character literal containing a single <i>c-char</i> not 
representable in the execution character set, is conditionally-supported, has 
type <code>int</code>, and has an implementation-defined value.</p>
<p><sup>3</sup> A character literal that begins with <code>u8</code>, such as
<code>u8’w</code>’, is a character literal of type <code>char</code>, known as a
<i>UTF-8<br>
character literal</i>. The value of a UTF-8 character literal is equal to its 
ISO 10646 code point value, provided<br>
that the code point value is representable with a single UTF-8 code unit (that 
is, provided it is in the C0<br>
Controls and Basic Latin Unicode block). If the value is not representable with 
a single UTF-8 code unit,<br>
the program is ill-formed. A UTF-8 character literal containing multiple <i>
c-chars</i> is ill-formed.</p>
<p><sup>4</sup> A character literal that begins with the letter <code>u</code>, 
such as <code>u’x’</code>, is a character literal of type <code>char16_t</code>. 
The<br>
value of a <code>char16_t</code> literal containing a single <i>c-char</i> is 
equal to its ISO 10646 code point value, provided that<br>
the code point is representable with a single 16-bit code unit. (That is, 
provided it is a basic multi-lingual<br>
plane code point.) If the value is not representable within 16 bits, the program 
is ill-formed. A <code>char16_t</code><br>
literal containing multiple <i>c-chars</i> is ill-formed.</p>
<p><sup>5</sup> A character literal that begins with the letter <code>U</code>, 
such as <code>U’y’</code>, is a character literal of type <code>char32_t</code>. 
The<br>
value of a <code>char32_t</code> literal containing a single <i>c-char</i> is 
equal to its ISO 10646 code point value. A <code>char32_t</code><br>
literal containing multiple <i>c-chars</i> is ill-formed.</p>
<p><sup>6</sup> A character literal that begins with the letter <code>L</code>, such as
<code>L’z’</code>, is a wide-character literal. A wide-character literal has type
<code>wchar_t</code>. 
The value of a wide-character literal containing a single <i>c-char</i>
<del>has value equal 
to the numerical value of the encoding of the <i>c-char</i> in the execution 
wide-character set, unless the <i>c-char</i> has no representation in the execution 
wide-character set, in which case the value is implementation-defined. [ Note: 
The type <code>wchar_t </code>is able to represent all members of the execution 
wide-character set (see 3.9.1). —end note ]. The value of a wide-character 
literal containing multiple <i>c-chars</i> is implementation-defined.</del> <ins>is 
equal to its ISO 10646 code point value, provided that code point value is 
representable with a single UTF encoded code unit. If the value is not representable 
with a single UTF encoded code unit, the program is ill-formed. The specific 
UTF form is determined by the size of <code>wchar_t</code>. A 
wide-character&nbsp;literal containing multiple <i>c-chars</i> is ill-formed.</ins></p>

<h3>2.13.5 String literals [lex.string]</h3>
<p><sup>7</sup> A <i>string-literal</i> that begins with <code>u8</code>, 
such as <code>u8&quot;asdf&quot;</code>, is a UTF-8 string literal.</p>
<p><sup>8</sup> Ordinary string literals and UTF-8 string literals are 
also referred to as narrow string literals. A narrow string literal has type 
“array of <i>n</i> <code>const char</code>”, where <i>n</i> is the size of the 
string as defined below, and has static storage duration (3.7).</p>
<p><sup>9</sup> For a UTF-8 string literal, each successive element of 
the object representation (3.9) has the value of the corresponding code unit of 
the UTF-8 encoding of the string.</p>
<p><sup>10</sup> A <i>string-literal</i> that begins with <code>u</code>, 
such as <code>u&quot;asdf&quot;</code>, is a <code>char16_t</code> string literal. A <code>
char16_t</code> string literal has type “array of <i>n</i> <code>const char16_t</code>”, 
where <i>n</i> is the size of the string as defined below; <del>it is initialized 
with the given characters</del> <ins>each successive element of 
the object representation  has the value of the corresponding code unit of 
the UTF-16 encoding of the string</ins>. A single <i>c-char</i> may produce more than one
<code>char16_t</code> character in the form of surrogate pairs.</p>
<p><sup>11</sup> A <i>string-literal</i> that begins with <code>U</code>, 
such as <code>U&quot;asdf&quot;</code>, is a <code>char32_t</code> string literal. A <code>
char32_t</code> string literal has type “array of <i>n</i> <code>const char32_t</code>”, 
where <i>n</i> is the size of the string as defined below; <del>it is initialized 
with the given characters</del> <ins>each successive element of 
the object representation  has the value of the corresponding code unit of 
the UTF-32 encoding of the string</ins>.</p>
<p><sup>12</sup> A <i>string-literal</i> that begins with <code>L</code>, 
such as <code>L&quot;asdf&quot;</code>, is a wide string literal. A wide string literal 
has type “array of <i>n</i> <code>const wchar_t</code>”, where <i>n</i> is the 
size of the string as defined below; <del>it is initialized 
with the given characters</del> <ins>each successive element of the object 
representation  has the value of the corresponding code unit of the UTF encoding of the 
string.</ins></p>
<p><sup>15</sup> Escape sequences and universal-character-names in 
non-raw string literals have the same meaning as in character literals (2.13.3), 
except that the single quote <code>’</code> is representable either by itself or 
by the escape sequence <code>\’</code>, and the double quote <code>&quot;</code> 
shall be preceded by a <code>\</code>, and except that a 
universal-character-name in a <code>char16_t</code> string literal may yield a 
surrogate pair. In a narrow string literal, a universal-character-name may map 
to more than one char element due to multibyte encoding. The size of a <code>
char32_t</code> <del>or wide</del> string literal is the total number of escape sequences, 
universal-character-names, and other characters, plus one for the terminating
<code>U’\0’</code><del> or L’\0’</del>. The size of a <code>char16_t</code> 
string literal is the total number of escape sequences, 
universal-character-names, and other characters, plus one for each character 
requiring a surrogate pair, plus one for the terminating <code>u’\0’</code>. [ Note: The size of a <code>char16_t</code> string literal is the number of code 
units, not the number of characters. —end note ] <ins>The size of a <code>wchar_t</code> string literal is the total number of 
code units necessary to represent the code points for all escape sequences, 
universal-character-names, and other characters, plus one for the terminating
<code>L’\0’</code>.</ins> Within <ins><code>wchar_t</code>,</ins> <code>char32_t</code> 
and <code>char16_t</code> literals, any universal-character-names shall be 
within the range <code>0x0</code> to <code>0x10FFFF</code>. The size of a narrow 
string literal is the total number of escape sequences and other characters, 
plus at least one for the multibyte encoding of each universal-character-name, 
plus one for the terminating <code>’\0’</code>.</p>
<h3>2.3 Character sets [lex.charset]</h3>
<p><sup>3</sup> The <i>basic execution character set</i> <del>and the <i>basic execution wide-character</i> set</del> 
shall <del>each</del> contain all the members of the basic source character set, plus 
control characters representing alert, backspace, and carriage return, plus a 
<i>null character </i>(respectively, <i>null wide character</i>), whose value is 0. 
<i><del>For each basic execution character set</del></i><del><i>, the</i></del>
<ins>The</ins> values of the members<ins> of the basic execution character set</ins> shall be non-negative 
and distinct from one another. In both the source and execution basic character 
sets, the value of each character after 0 in the above list of decimal digits 
shall be one greater than the value of the previous. The <i>execution character set</i>
<del>and the execution wide-character set are</del> <ins>is an</ins> implementation-defined superset<del>s</del> of the 
basic execution character set and the basic execution wide-character set, 
respectively. The values of the members of the execution character sets and the 
sets of additional members <del>are</del> <ins>may be</ins> locale-specific.</p>
<h3>3.9.1 Fundamental types [basic.fundamental]</h3>
<p><sup>5</sup> Type <code>wchar_t</code> is a distinct type whose values can represent 
distinct <del>codes</del> <ins>code units</ins> for all <del>members of the largest extended character set specified 
among the supported locales (22.3.1).</del> <ins>code points defined by ISO/IEC 10646.</ins> Type <code>wchar_t</code> shall have the 
same size, signedness, and alignment requirements (3.11) as one of the other 
integral types, called its underlying type. Types <code>char16_t</code> and
<code>char32_t</code> denote distinct types with the same size, signedness, and 
alignment as <code>uint_least16_t</code> and <code>uint_least32_t</code>, 
respectively, in <code>&lt;cstdint&gt;</code>, called the underlying types.</p>
<h3>16.8 Predefined macro names [cpp.predefined]</h3>
<p><sup>2</sup> <code>__STDC_ISO_10646__</code><br>
An integer literal of the form <code>yyyymmL</code> (for example, <code>199712L</code>). 
If this symbol is defined, then every
character in the Unicode required set, when stored in an object of type <code>
wchar_t</code>, has the same value as
the short identifier of that character. The <i>Unicode required set </i>consists 
of all the characters that are
defined by ISO/IEC 10646, along with all amendments and technical corrigenda as 
of the specified year
and month</p>
<h3><ins>17.6.3.6 Character sequence requirements [utility.req.encoding]</ins></h3>
<p><ins>Unless otherwise specified, the encoding of strings and  
sequences of narrow character types and types <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, 
and <code>wchar_t</code> shall be the same encoding as character literals of 
those types ([lex.ccon]). [<i>Note</i>: those encodings are the encoding of the execution 
character set, UTF-16, UTF-32, and a size-dependent UTF encoding, respectively. 
&mdash;<i>end note</i>]</ins></p>
<h3>22.3.3.2.2 string conversions [conversions.string]</h3>
<p><sup><font face="Arial">1</font></sup> Class template <code>wstring_convert</code> 
performs conversions between a wide string and a byte string. It lets you 
specify a code conversion facet (like class template <code>codecvt</code>) to 
perform the conversions, without affecting any streams or locales. [ <i>Example:</i> If 
you <ins>often</ins> want to use the code conversion facet <code>codecvt_utf8</code> to output to
<code>cout</code> a UTF-8 multibyte sequence corresponding to a wide string, but 
you don’t want to alter the locale for <code>cout</code>, you can write 
something like:</p>
<blockquote>
  <pre><del>wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; myconv;
std::string mbstring = myconv.to_bytes(L&quot;Hello\n&quot;);
std::cout &lt;&lt; mbstring;</del></pre>
  <pre><ins>std::string utf8(std::wstring_view v) {
  static std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt; myconv;
  return myconv.to_bytes(v.cbegin(), v.cend());
}


std:wstring my_wstring(L&quot;你好，世界&quot;);

std::cout &lt;&lt; utf8(my_wstring);</ins></pre>
</blockquote>
<p><ins>This code is portable regardless of whether the encoding of <code>wchar_t</code> 
strings is UTF-8, UTF-16, or UTF-32.</ins></p>
<p><i>—end example</i> ]</p>
<h3>27.10.4.10 native encoding [fs.def.native.encode]</h3>
<p dir="ltr">For narrow character strings <ins>and sequences</ins>, the operating system dependent current encoding 
for pathnames (27.10.4.17). <del>For wide character strings, the implementation 
defined execution wide-character set encoding(2.3).</del> <ins>[<i>Note</i>: 
For strings and sequences of types <code>char16_t</code>, <code>char32_t</code>, and 
<code>wchar_t</code>, see [utility.req.encoding] 
&mdash;end note]</ins></p>
<hr>
<p>&nbsp;</p>
<p>Remove all references to <i>&quot;execution wide-character set&quot;</i></p>
<p><i>Problem: There is no normative definition of &quot;extended 
character set&quot;. There is only a non-normative note in 1.3.14 multibyte character [defns.multibyte] 
that says &quot;[Note: The extended character set is a superset of the basic 
character set (2.3).—end note ] and it is a stretch to understand how to apply 
that &quot;</i></p>
<p><i>Problem: Neither 22.3.1 nor anywhere else in 22 specifies what the 
supported locals are. We can guess that the global local and the C locale are 
supported, and perhaps any locale that can be constructed without error is 
supported, but that is never stated.</i></p>
<p><i>Problem: Even if supported locales were defined, locales do not appear to 
have character sets specified, except perhaps by guessing based on the name.</i></p>

<p>&nbsp;</p>

<p><i>Problem: The standard library has some components, such as class path 
native format observers (27.10.8.4.6) that cannot be implemented without knowing 
the encoding of various kinds of strings or, alternately, need to specify what 
string encodings they assume.</i></p>

</body>

</html>