<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
 ins  {background-color: #CCFFCC; text-decoration: none;}
 del  {background-color: #FFCACA; text-decoration: none;}
 a    {text-decoration: none;}
</style>
<title>Filesystem NB Comments C++17</title>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left">D0492R0</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-11-08<!--webbot bot="Timestamp" endspan i-checksum="12118" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library</td>
</tr>
</table>

<h1>Proposed Resolution of C++17  National Body Comments for Filesystem(R0)</h1>

<p>This document proposes resolutions of C++17 National Body Comments from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">
P0488R0</a> related to
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4606.pdf">
N4606</a> 27.10 [filesystems]. Late Comments from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0489r0.pdf">
P0489R0</a> are also considered, in a separate section.</p>

<p>The proposed resolutions in the initial draft of this paper represent only 
the author&#39;s views. They do not necessarily represent the views of the Library 
Working Group (LWG) or the C++ committee. The tentative plan is that they will 
be reviewed and revised 
in Issaquah, first by a small LWG group, then by the full LWG, and then the revised version 
presented to the full committee on Friday.</p>

<p><b><a href="#nb-comments">NB Technical and general comments</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US25">US 25: has_filename() is equivalent to just !empty()</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US31">US 31: Everything is defined in terms of one implicit host system</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US32">US 32: Meaning of 27.10.2.1 unclear</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US33">US 33: Definition of <i>canonical path</i> problematic</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US34">US 34: Are there attributes of a file that are not an aspect of the file system?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US35">US 35: What synchronization is required to avoid a file system race?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US36">US 36: Symbolic links themselves are attached to a directory via (hard) links</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US37">US 37: The term “redundant current directory (dot) elements” is not defined</a><br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US40">US 40: Not all directories have a parent.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US43">US 43: Concerns about <i>encoded character types</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US44">US 44: Definition of path in terms of a string requires leaky abstraction</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US45">US 45: Generic format portability compromised by unspecified root-name</a><br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US46">US 46: <i>filename</i> can be empty so productions for <i>relative-path</i> are redundant</a><br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US48">US 48: Multiple separators are often meaningful in a <i>root-name</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US49">US 49: What does “method of conversion method” mean?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US51">US 51: Failing to add / when appending empty string prevents useful apps</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US52">US 52: <code>remove_filename()</code> postcondition is not by itself a definition</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US53">US 53: <code>remove_filename()</code>'s name does not correspond to its behavior</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US54">US 54: <code>remove_filename()</code> is broken</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US55">US 55: <code>replace_extension()</code>'s use of <code>path</code> as parameter is inappropriate</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US56">US 56: Remove <code>replace_extension()</code>&#39;s conditional addition of period</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US57">US 57: On Windows, absolute paths will sort in among relative paths</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US58">US 58: <code>parent_path()</code> behavior for root paths is useless</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US59">US 59: <code>filename()</code> returning <code>path</code> for single path components is bizarre</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US60">US 60: <code>path(&quot;/foo/&quot;).filename()==path(&quot;.&quot;)</code> is surprising</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US61">US 61: Leading dots in <code>filename()</code> should not begin an extension</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US62">US 62: It is important that <code>stem()+extension()==filename()</code></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US63">US 63: <code>lexically_normal()</code> inconsistently treats trailing "/" but not &quot;/..&quot; as directory</a><br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US185">US 185: Fold <code>error_code</code> and non-<code>error_code</code> signatures into one signature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FI14">FI 14: <tt>directory_entry</tt> comparisons are members</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US73">US 73, CA 2: <i>root-name</i> is effectively implementation defined</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US74">US 74, CA 3: The term “pathname” is ambiguous in some contexts</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US75">US 75, CA 4: Extra flag in path constructors is needed</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US76">US 76, CA 5: <i>root-name</i> definition is over-specified.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US77">US 77, CA 6: <code>operator/</code> and other appends not useful if arg has <i>root-name</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US78">US 78, CA 7: Member <code>absolute()</code> in 27.10.4.1 is overspecified for non-POSIX-like O/S</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US79">US 79, CA 8: Some  operation functions are overspecified for implementation-defined file types</a><br>
<b><a href="#editorial">NB comments submitted as editorial</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US38">US 38: Duplicates §17.3.16</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US39">US 39: Remove note: Dot and dot-dot are not directories</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US41">US 41: The term “parent directory” for a (non-directory) file is unusual</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US42">US 42: Pathname resolution does not always resolve a symlink</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US47">US 47: “.” and “..” already match the name production</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US50">US 50: 27.10.8.1 ¶ 1.4 largely redundant with ¶ 1.3</a><br>
<b>
<a href="#late-comments">Late comments</a></b>

<h2><a name="nb-comments"></a>NB Technical and general comments</h2>

<h3>Comments related to <code>filename()</code></h3>

<p>Note: No late comments are related to filename comments</p>

<h4><a name="US25">US 25</a>; 27.10.8.4.10 [path.query]: <code>has_filename()</code> is equivalent to just 
<code>!empty()</code></h4>
<blockquote>
<p>No Proposed wording. The real issue is a possibly incorrect post-condition for 
<code>remove_filename()</code>. </p>

<p>SG recommends revisiting this comment after other filename related comments 
have been resolved.</p>

</blockquote>

<h4><a name="US37">US 37</a>; 27.10.4.12 [fs.def.normal.form]: The term “redundant current directory (dot) elements” is not defined</h4>
<blockquote>
<p><i>Change 27.10.4.12 [fs.def.normal.form]:</i></p>
<blockquote>
<p><b>normal form</b><br>
A path with no <del>redundant</del> current directory (<i>dot</i>) elements <ins>
except possibly one at the end</ins>, no redundant parent directory (<i>dot-dot</i>) 
elements, and no redundant <i>directory-separators</i>. The normal form for an 
empty path is an empty path. The normal form for a path ending in a <i>
directory-separator</i> that is not the root directory has a current directory (<i>dot</i>) 
element appended. A path in normal form is said to be <i>normalized</i>. The 
process of obtaining a normalized path from a path that is not in normal form is 
called <i>normalization</i>. [ <i>Note</i>: The rule that appends a current 
directory (<i>dot</i>) element supports operating systems like OpenVMS that use 
different syntax for directory names and regular file names. —<i>end note</i> ]</p>
</blockquote>
<p>SG recommends accept with modifications.</p>
</blockquote>

<h4><a name="US51">US 51</a>; 27.10.8.4.3 [path.append] ¶2.3: Failing to add / when appending empty string prevents useful apps</h4>
<blockquote>

<p><i>Change 27.10.8.4.3 [path.append]:</i></p>
  
  <blockquote>
    <p ALIGN="LEFT"><code>path&amp; operator/=(const path&amp; p);</code></p>
    </font><font FACE="LMRoman7-Regular" SIZE="1">
    <p ALIGN="LEFT">2 </font><font FACE="LMRoman10-Italic"><i>Effects:
    </i></font><font FACE="LMRoman10-Regular">Appends </font>
    <font FACE="LMMono10-Regular">path::preferred_separator </font>
    <font FACE="LMRoman10-Regular">to </font>
    <font FACE="LMMono10-Regular">pathname </font>
    <font FACE="LMRoman10-Regular">unless:</p>
    </font><font FACE="LMRoman7-Regular" SIZE="1">
    <p ALIGN="LEFT">(2.1) </font><font FACE="LMRoman10-Regular">— an 
    added </font><font FACE="LMRoman10-Italic"><i>directory-separator
    </i></font><font FACE="LMRoman10-Regular">would be redundant, or</p>
    </font><font FACE="LMRoman7-Regular" SIZE="1">
    <p ALIGN="LEFT">(2.2) </font><font FACE="LMRoman10-Regular">— </font>
    <ins><code>p.empty()</code> is <code>false</code> and</ins> an added <i>directory-separator</i><font FACE="LMRoman10-Regular">would change a relative 
    path into an absolute path [</font><font FACE="LMRoman10-Italic"><i>Note:
    </i></font><font FACE="LMRoman10-Regular">An empty path is relative.</font><font FACE="LMRoman10-Italic"><i>—end 
    note </i></font><font FACE="LMRoman10-Regular">] , or</p>
    </font><font FACE="LMRoman7-Regular" SIZE="1">
    <p>(2.3) </font><font FACE="LMRoman10-Regular">—
    </font><del><code>p.empty()</code> is <code>true</code>, 
    or</del></p>
    <font FACE="LMRoman7-Regular" SIZE="1">
    <p ALIGN="LEFT">(2.4) </font><font FACE="LMRoman10-Regular">—
    </font><font FACE="LMMono10-Regular">*p.native().cbegin() </font>
    <font FACE="LMRoman10-Regular">is a </font>
    <font FACE="LMRoman10-Italic"><i>directory-separator</i></font><font FACE="LMRoman10-Regular">.</p>
    <p ALIGN="LEFT">Then appends </font><font FACE="LMMono10-Regular">
    p.native() </font><font FACE="LMRoman10-Regular">to </font>
    <font FACE="LMMono10-Regular">pathname</font><font FACE="LMRoman10-Regular">.</p>
    </font><font FACE="LMRoman7-Regular" SIZE="1">
    <p>3 </font><font FACE="LMRoman10-Italic"><i>Returns: </i></font>
    <font FACE="LMMono10-Regular">*this</font><font FACE="LMRoman10-Regular">.</font></p>
  </blockquote>

    <p>SG recommends accept with modifications.<font FACE="LMRoman10-Regular"></p>

</blockquote>

<h4><a name="US52">US 52</a>; 27.10.8.4.5 [path.modifiers] ¶5: <code>remove_filename()</code> postcondition is not by itself a definition</h4>
<blockquote>
<p>
<i>Change 27.10.8.4.5 [path.modifiers] ¶5:</i> </p>
<blockquote>
 <p>
 <del><i>Postcondition:</i><code>!has_filename()</code>.</del> </p>
 <p> <ins><i>Effects:</i> 
 If <code>has_filename()</code> then remove the minimum number of trailing 
 characters from <code>pathname</code> such that there is one less element in
 <code>[begin(), end())</code>. Otherwise, no effect.</ins></p>
</blockquote>
 <p> SG recommends accept with modifications.</p>
</blockquote>

<h4><a name="US53">US 53</a>; 27.10.8.4.5 [path.modifiers] ¶7: <code>remove_filename()</code>'s name does not correspond to its behavior</h4>

<blockquote>

<p>Because of a possible trailing &quot;/&quot;, this comment is technically correct. The 
real question (for the full LWG) is do we want to make a name change at this 
late date for a name that is &quot;good enough&quot;.</p>

<p>This issue probably needs to be resolved before C++17 ships, since a name 
change is a breaking change.</p>
<p>Bikeshed:
<code>remove_last_element()</code> rather than the suggested <code>remove_component()</code>.<p>
  <b>Caution:</b> &quot;remove_filename&quot; appears at least seven times in 
  sub-clause 27.10. All will need to be changed if the name changes.<p><b>Caution:</b> &quot;replace_filename&quot; 
  presumably also would need to be renamed.</blockquote>

<h4><a name="US54">US 54</a>; 27.10.8.4.5 [path.modifiers] ¶10: <code>remove_filename()</code> is broken</h4>

<blockquote>

<p>Need to resolve <a href="#US53">US 53</a> first.</p>

</blockquote>

<h4><a name="US60">US 60</a>; 27.10.8.4.9 [path.decompose] ¶6: <code>path(&quot;/foo/&quot;).filename()==path(&quot;.&quot;)</code> is surprising</h4>

<blockquote>

<p>The <code>filename()</code> behavior at issue is specified in 27.10.8.4.9 [path.decompose] ¶6:</p>

<blockquote>

<p><i>Returns</i>: <code>empty() ? 
path() : *--end()</code>.</p>

</blockquote>

<p>So the underlying problem is in 27.10.8.5 path iterators [path.itr]
¶4:</p>

  <blockquote>

<font FACE="LMRoman7-Regular" SIZE="1">
<p ALIGN="LEFT">4 </font><font FACE="LMRoman10-Regular">For the 
elements of </font><font FACE="LMMono10-Regular">pathname </font>
<font FACE="LMRoman10-Regular">in the generic format, the forward 
traversal order is as follows:</p>
</font><font FACE="LMRoman7-Regular" SIZE="1">
<p ALIGN="LEFT">(4.1) </font><font FACE="LMRoman10-Regular">— The
</font><font FACE="LMRoman10-Italic"><i>root-name </i></font>
<font FACE="LMRoman10-Regular">element, if present.</p>
</font><font FACE="LMRoman7-Regular" SIZE="1">
<p ALIGN="LEFT">(4.2) </font><font FACE="LMRoman10-Regular">— The
</font><font FACE="LMRoman10-Italic"><i>root-directory </i></font>
<font FACE="LMRoman10-Regular">element, if present. [</font><font FACE="LMRoman10-Italic"><i>Note:
</i></font><font FACE="LMRoman10-Regular">the generic format is 
required to ensure lexicographical</p>
<p ALIGN="LEFT">comparison works correctly. </font>
<font FACE="LMRoman10-Italic"><i>—end note </i></font>
<font FACE="LMRoman10-Regular">]</p>
</font><font FACE="LMRoman7-Regular" SIZE="1">
<p ALIGN="LEFT">(4.3) </font><font FACE="LMRoman10-Regular">— Each 
successive </font><font FACE="LMRoman10-Italic"><i>filename </i></font>
<font FACE="LMRoman10-Regular">element, if present.</p>
</font><font FACE="LMRoman7-Regular" SIZE="1">
<p>(4.4) </font><font FACE="LMRoman10-Regular">— </font>
<font FACE="LMRoman10-Italic"><i>dot</i></font><font FACE="LMRoman10-Regular">, 
if one or more trailing non-root </font><font FACE="LMRoman10-Italic">
<i>slash </i></font><font FACE="LMRoman10-Regular">characters are 
present.</p>
</font>

  </blockquote>

<p>The ¶4.4 iterator behavior has always been surprising and controversial, so 
the LWG SG looked at the possible ways of dealing with trailing non-root slash 
characters.</p>

<blockquote>

<p><del> <i>dot</i>, if one or more trailing non-root <i>
slash</i> characters are present.</del></p>

<blockquote>

<p>Not acceptable because it loses the fact that the path represents a 
directory, yet knowing that is required for some operating systems e.g. POSIX, 
z/OS, OpenMVS).&nbsp; It also ensures that reconstruction by iteration yields 
the same path as the original for some definition ofoncer &quot;same&quot;.</p>

</blockquote>

<p> <i><del>dot</del> <ins>slash</ins></i>, if one or more trailing non-root <i>
slash</i> characters are present.</p>

<blockquote>

<p>Not acceptable because (ask Jonathan - three people spoke at once and I lost 
the thread of conversation)</p>

</blockquote>

<p> <i><del>dot</del> </i><ins>an empty element</ins>, if one or more trailing non-root <i>
slash</i> characters are present.</p>

<blockquote>

<p>This works, and was discussed at length by the SG. It appears to resolve a 
number of concerns raised by other NB comments and by the SG during discussion 
of those comments. A paper is needed to identify all the ripple effects of this 
change, and propose wording changes where needed or desirable.&nbsp; </p>

</blockquote>

</blockquote>

<p>The SG encourages such a paper.</p>

</blockquote>

<h4 dir="ltr">LWG 2665 <code>remove_filename()</code> post condition is 
incorrect</h4>

<blockquote>

<p dir="ltr">Although not a NB comment,
<a href="http://cplusplus.github.io/LWG/lwg-active.html#2665">LWG 2665</a> needs 
to be coordinated with this set of comments.</p>

</blockquote>
</font>

<h3>Other comments</h3>

<h4><a name="US31">US 31</a>; 27.10 [filesystems]: Everything is defined in terms of one implicit host system</h4>
<blockquote>
<p>That&#39;s by design, aimed at achieving portable syntax and portable behavior. 
And that objective has been largely achieved in practical real-world use for 
many years.&nbsp; No proposed wording. </p>

<p>SG recommends waiting for a paper or issue with proposed wording. </p>

</blockquote>

<h4><a name="US32">US 32</a>; 27.10.2.1 [fs.conform.9945] ¶3: Meaning of POSIX 
conformance unclear</h4>

<blockquote>

<p dir="ltr">The comment requests &quot;Clarify that ¶2 governs and an error must be 
reported in such cases&quot;.</p>

<p dir="ltr"><i>Change 27.10.2.1 [fs.conform.9945] ¶2:</i></p>
  <blockquote>
    <p>Implementations are not required to provide behavior that is not 
    supported by a particular file system. [ Example: The FAT file system used 
    by some memory cards, camera memory, and floppy disks does not support hard 
    links, symlinks, and many other features of more capable file systems, so 
    implementations are not required to support those features on the FAT file 
    system <ins>but instead are required to report an error as described above</ins>. —end example ]</p>
  </blockquote>
    <p>Jonathan Wakely will supply improved wording.</p>
</blockquote>
<h4><a name="US33">US 33</a>; 27.10.4.2 [fs.def.canonical.path]: Definition of <i>canonical path</i> problematic</h4>
<blockquote>
<p>The comment appears to be correct in that the definition of canonical path is 
not used in the WP.</p>
<p><i>Remove 27.10.4.2 [fs.def.canonical.path]:</i></p>
<blockquote>
<p><del><b>canonical path</b><br>
An absolute path that has no elements that are symbolic links, and no dot or 
dot-dot elements (27.10.8.1).</del></p>
</blockquote>
<p>SG recommends accept.</p>
</blockquote>
<h4><a name="US34">US 34</a>; 27.10.4.5 [fs.def.filesystem]: Are there attributes of a file that are not an aspect of the file system?</h4>
<blockquote>
<p><i>Change 27.10.4.5 [fs.def.filesystem]:</i></p>
  <blockquote>
<p>A collection of files and <del>certain of</del> their attributes.</p>
  </blockquote>
<p>SG recommends accept with modifications.</p>
</blockquote>
<h4><a name="US35">US 35</a>; 27.10.4.6 [fs.def.race]: What synchronization is required to avoid a file system race?</h4>
<blockquote>
<p>No proposed wording. 27.10.4 Terms and definitions [fs.definitions] is not the proper place to 
describe file system race behavior. 27.10.2.3 File system race behavior [fs.race.behavior] 
would be the proper place. </p>
<p>SG recommends waiting for a paper or issue with proposed wording. </p>
</blockquote>
<h4><a name="US36">US 36</a>; 27.10.4.9 [fs.def.link]: Symbolic links themselves are attached to a directory via (hard) links</h4>
<blockquote>
<p>The SG provides wording, taken from POSIX definitions 3.130, Directory Entry 
(or Link).</p>
<p><i>Change 27.10.4.9 [fs.def.link]:</i></p>
  <blockquote>
<p><b>link</b><br>
<del>A directory entry that associates a filename with a file. A link is either 
a hard link (27.10.4.8) or a symbolic link (27.10.4.21).</del> <ins>An object 
that associates a filename with a file. Several link entries can associate names 
with the same file.</ins></p>
  </blockquote>
<h4><span style="font-weight: 400">SG recommends accept with modifications. 
Davis Herring will open an issue on a related concern.</span></h4>
</blockquote>
<h4><a name="US40">US 40</a>; 27.10.4.15 [fs.def.parent]: Not all directories 
have a parent</h4>

<blockquote>
<p>No proposed wording. The definition in question is taken directly from 
the POSIX
<font face="Times New Roman">§</font>3.268 <i>Parent Directory</i> definition. </p>

<p>SG recommends reject.</p>

</blockquote>

<h4><a name="US43">US 43</a>; 27.10.5 [fs.req] ¶4: Concerns about <i>encoded character types</i></h4>

<blockquote>

<p>&nbsp;No proposed wording.  </p>

<p><i>Change 27.10.5 
Requirements [fs.req] ¶4:</i></p>

  <blockquote>

<p>Note: Use of an encoded character type implies an associated <ins>character set and</ins> encoding.
Since <code>signed char</code> and <code>unsigned char</code> have 
no implied <ins>character set and</ins> encoding, they are not included as permitted types. 
—end note ]</p>

  </blockquote>

<p>SG recommends accept with modifications.</p>

<p>The SG also detected a problem with conversions that fail, and a need that 
directory-separator detection occur at the code-unit level. Billy O&#39;neil and 
Jonathan Wakely will provide issue write ups.</p>

</blockquote>

<h4><a name="US44">US 44</a>; 27.10.8 [class.path]: Definition of path in terms of a string requires leaky abstraction</h4>
<blockquote>
<p>No proposed wording.</p>

<p>SG recommends that resolution of this comment be deferred until LWG 2734 is 
resolved. It is expected that issue will be resolved as a native path. Add a 
note to 27.10.8.4.4 to the effect that &quot;a non-portable path may result because 
&#39;/&#39; is non-portable.&quot;</p>

</blockquote>

<h4><a name="US45">US 45</a>; 27.10.8.1 [path.generic]: Generic format portability compromised by unspecified 
<i>root-name</i></h4>
<blockquote>
<p>No 
proposed wording. Davis Herring working on proposed wording.</p>

</blockquote>

<h4><a name="US46">US 46</a>; 27.10.8.1 [path.generic]: <i>filename</i> can be empty so productions for <i>relative-path</i> are redundant</h4>
<blockquote>
<p>No proposed wording. Jonathan Wakely will provide proposed wording.</p>

</blockquote>

<h4><a name="US48">US 48</a>; 27.10.8.1 [path.generic] ¶1: Multiple separators are often meaningful in a <i>root-name</i></h4>
<blockquote>

<p><i>Change 27.10.8.1 [path.generic] ¶1:</i></p>

  <blockquote>
<p><ins>Except in <i>root-name</i>, m</ins><del>M</del>ultiple successive <i>
directory-separator</i> characters are considered to be the same as one <i>
directory-separator </i>character.</p>

  </blockquote>
<p>SG recommends accept with modifications.</p>

</blockquote>

<h4><a name="US49">US 49</a>; 27.10.8.2.2 [path.type.cvt]: What does “method of conversion method” mean?</h4>
<blockquote>

<p><i>Change 27.10.8.2.2 [path.type.cvt]:</i></p>

  <blockquote>
    <ul>
      <li><i>¶1.2:</i> method of conversion <del>method</del> is unspecified</li>
      <li><i>¶1.3:</i> method of conversion <del>method</del> is unspecified</li>
      <li><i>¶1.4:</i> method of conversion <del>method</del> is unspecified</li>
    </ul>
  </blockquote>
<p>SG recommends accept with modifications.</p>
</blockquote>

<font FACE="LMRoman10-Regular">

<h4><a name="US55">US 55</a>; 27.10.8.4.5 [path.modifiers] ¶11: <code>replace_extension()</code>'s use of <code>path</code> as parameter is inappropriate</h4>

<blockquote>
<p>The SG believes <code>path</code> is the appropriate parameter type, but that 
the standard needs to clarify class <code>path</code> usage.</p>
<p><i>Change 27.10.8 [class.path] ¶1:</i></p>

<blockquote>
<p>An object of class path represents a path (27.10.4.17)
 and contains a pathname (27.10.4.18). Such an object
is concerned only with the lexical and syntactic aspects of a path. The path does not necessarily exist in
external storage, and the pathname is not necessarily valid for the current operating system or for a particular
file system.</p>

<p><ins>[<i>Note:</i> Class path is used to abstract away the differences between the string types
 used by different operating systems to represent pathnames, and to perform 
conversions between encodings when necessary. &mdash; <i>end note</i>]</ins></p>

</blockquote>
 
 <p> SG recommends accept with modifications.
 <span style="background-color: #FFFF00">Note: SG should review wording 
 &quot;abstract away&quot; rather than &quot;support&quot;.</span></p>
 
</blockquote>
 
<h4><a name="US56">US 56</a>; 27.10.8.4.5 [path.modifiers] ¶11.2: Remove <code>
replace_extension()</code>&#39;s conditional addition of period</h4>

<blockquote>
 
<p>An example of where the current behavior is useful: <code>
path(&quot;my_file.tx&quot;).replace_extension(&quot;txt&quot;)</code></p>

<p>An example of a case where the current behavior is unsatisfactory would be 
helpful.</p>

<p>Recommend reject, unless someone can come up with stronger motivation.</p>

</blockquote>

<h4><a name="US57">US 57</a>; 27.10.8.4.8 [path.compare] ¶2: On Windows, absolute paths will sort in among relative paths</h4>

<blockquote>

<p>It isn&#39;t clear why this matters; an example would help.</p>

<p>Recommend reject. Insufficient motivation for change. No proposed 
wording.</p>

</blockquote>

<h4><a name="US58">US 58</a>; 27.10.8.4.9 [path.decompose] ¶5: <code>parent_path()</code> behavior for root paths is useless</h4>

<blockquote>

<p>The example given (<code>path(&quot;c:\\&quot;).parent_path()</code> on 
Windows returns <code>path(&quot;c:&quot;)</code>) seems useful. </p>

<p>Recommend reject. Insufficient motivation for change.&nbsp; No proposed 
wording.</p>

</blockquote>

<h4><a name="US59">US 59</a>; 27.10.8.4.9 [path.decompose] ¶6: <code>filename()</code> returning <code>path</code> for single path components is bizarre</h4>

<blockquote>

<p>Recommend reject. <code>path</code> is filesystem's
vocabulary type for both full paths and for path components, in the same sense that
<code>std::string</code> might be used as the vocabulary type for both sentences and 
the words in the
sentences. See <a href="#US55">US 55</a> for further discussion.</p>

</blockquote>

<h4><a name="US61">US 61</a>; 27.10.8.4.9 [path.decompose] ¶8: Leading dots in <code>filename()</code> should not begin an extension</h4>

<blockquote>

<p>Cases that seem worth considering, with suggested decompositions:</p>

<blockquote>

  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td><i><b><code>path p</code></b></i></td>
      <td><i><b><code>p.stem()</code></b></i></td>
      <td><i><b><code>p.extension()</code></b></i></td>
    </tr>
    <tr>
      <td><code>&quot;.bashrc&quot;</code></td>
      <td><code>&quot;.bashrc&quot;</code></td>
      <td>&quot;&quot;</td>
    </tr>
    <tr>
      <td><code>&quot;..abc&quot;</code></td>
      <td><code>&quot;..abc&quot;</code></td>
      <td>&quot;&quot;</td>
    </tr>
    <tr>
      <td>&quot;<code>...abc</code>&quot;</td>
      <td>&quot;<code>...abc</code>&quot;</td>
      <td>&quot;&quot;</td>
    </tr>
    <tr>
      <td>&quot;<code>abc..def</code>&quot;</td>
      <td>&quot;<code>abc</code>&quot;</td>
      <td>&quot;<code>..def</code>&quot;</td>
    </tr>
    <tr>
      <td>&quot;<code>abc...def</code>&quot;</td>
      <td>&quot;<code>abc</code>&quot;</td>
      <td>&quot;<code>...def</code>&quot;</td>
    </tr>
  </table>
</blockquote>

<p><i>Change 27.10.8.4.9 [path.decompose] ¶ 8:</i></p>

<blockquote>

<p><code>path stem() const;</code></p>

  <blockquote>

<p><i>Returns:</i> if <code>filename()</code> contains a period <del>but does not 
consist solely of one or two periods</del> <ins>other than in a sequence of one or 
more beginning periods</ins>, returns the substring of <code>filename()</code> 
starting at its beginning and ending with the character before the <del>last period</del> <ins>
first period of the last sequence of one or more periods</ins>.
Otherwise, returns <code>filename()</code>.</p>

  </blockquote>
</blockquote>

<p><i>Change 27.10.8.4.9 [path.decompose] ¶ 10:</i></p>

<blockquote>

<p><code>path extension() const;</code></p>

  <blockquote>

<p><i>Returns:</i> if <code>filename()</code> contains a period <del>but does not 
consist solely of one or two periods</del> <ins>other than in a sequence of one or 
more beginning periods</ins>, returns the substring of <code>filename()</code> 
starting at <ins>the beginning of</ins> the rightmost <ins>sequence of</ins> period<ins>s</ins> and for the remainder of the path. Otherwise, 
returns an empty <code>path</code> object.</p>

  </blockquote>
</blockquote>

</blockquote>

<h4><a name="US62">US 62</a>; 27.10.8.4.9 [path.decompose] ¶11: It is important that <code>stem()+extension()==filename()</code></h4>

<blockquote>

<p>Yes, it is important. But the note in ¶11 already says exactly that, so
the question becomes "Should we make that part of the note normative?"</p>

<p>Recommend reject. Saying that normatively would be a second way of saying 
what is already specified behavior, and saying the same normative thing twice is 
not good standardese. No proposed wording. </p>

</blockquote>

<h4><a name="US63">US 63</a>; 27.10.8.4.11 ¶1: <code>lexically_normal()</code> inconsistently treats trailing "/" but not &quot;/..&quot; as directory</h4>

<blockquote>

<p>Need proposed wording for the <i>Proposed change</i> "Append the /. in all cases known to name directories (if it is in fact necessary)".</p>

</blockquote>

<h4><b><a name="US185">US 185</a>; 27.10.7: </b>Fold <code>error_code</code> and non-<code>error_code</code> signatures into one signature</h4>

<blockquote>

<p>Recommend reject.</p>

<p> Does not handle one signature being <code>
noexcept(true)</code> and the other <code>noexcept(false)</code>, and many other 
problems. Even the submitter is no longer in favor. See LWG list thread 
&quot;[filesystem] US-185 Eliminating dual signatures for operational functions&quot;, 
October 25, 2016.</p>

</blockquote>

<h4><a name="FI 14">FI 14</a>; 27.10.12.3: <tt>directory_entry</tt> comparisons are members</h4>



<blockquote>

<p>Recommend reject.</p>

<p>This is LWG issue
<a href="http://cplusplus.github.io/LWG/lwg-closed.html#2761">2761</a>, which 
has been closed as NAD. </p>

</blockquote>



<h4><a name="US73">US 73</a>, CA 2; 27.10.8.1 [path.generic]: <i>root-name</i> is effectively implementation defined</h4>

<blockquote>

<p>The comment&#39;s proposed wording is to replace &quot;operating system dependent&quot; 
with &quot;implementation defined path prefix&quot;. </p>

<p>The comment&#39;s premise that &quot;<i>root-name</i> is effectively implementation defined&quot; 
is not correct. See 27.10.2.2 [fs.conform.os] and 27.10.4.14 [fs.def.osdep].</p>

<p>&quot;operating system dependent&quot; mandates different implementations for the same 
operating system produce the same behavior and that behavior must be that 
specified by the operating system, but &quot;implementation defined&quot; allows 
different implementations for the same operating system to produce different 
behavior, and it can differ from the normal behavior for the operating system.</p>

<p>Recommend reject. </p>

</blockquote>

<h4><a name="US74">US 74</a>, CA 3; 27.10.8 [class.path]: The term “pathname” is ambiguous in some contexts</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> Section 2.1</p>

</blockquote>

<h4><a name="US75">US 75</a>, CA 4; 27.10.8.4.1 [path.construct]: Extra flag in path constructors is needed</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.2</p>

</blockquote>

<h4><a name="US76">US 76</a>, CA 5; 27.10.8.1 [path.generic]: <i>root-name</i> definition is over-specified.</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.3.1</p>

</blockquote>

<h4><a name="US77">US 77</a>, CA 6; 27.10.8.4.3 [path.append]: <code>operator/</code> and other appends not useful if arg has <i>root-name</i></h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.3.2</p>

</blockquote>

<h4><a name="US78">US 78</a>, CA 7; 27.10.15.1 [fs.op.absolute]: Member <code>absolute()</code> in 27.10.4.1 is overspecified for non-POSIX-like O/S</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.4.1</p>

</blockquote>

<h4><a name="US79">US 79</a>, CA 8; Several: Some  operation functions are overspecified for implementation-defined file types</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.4.2</p>

</blockquote>



<h2><a name="editorial"></a>NB  comments submitted as editorial</h2>





<p>It isn&#39;t at all clear than any of these are really editorial. A ruling by the 
project editor is probably needed.</p>





<h4><a name="US38">US 38</a>; 27.10.4.13 [fs.def.symlink]:&nbsp; Duplicates §17.3.16.</h4>



<blockquote>

<p> Recommend reject. 27.10.4.13 provides additional wording&nbsp;not 
present in 17.3.16. </p>

</blockquote>



<h4><a name="US39">US 39</a>; 27.10.4.15: Remove note: Dot and dot-dot are not directories. </h4>



<blockquote>

<p> Recommend reject. The note was added to resolve confusion over dot and 
dot-dot.</p>

</blockquote>



<h4><a name="US41">US 41</a>; 27.10.4.16: The term “parent directory” for a (non-directory) file is unusual. </h4>


<blockquote>
<p>Recommend reject. Insufficient motivation for change. &quot;parent directory&quot; is the 
term we use to describe the containing directory, and to change that would imply 
changing at least one function name.</p>
</blockquote>

<h4><a name="US42">US 42</a>; 27.10.4.21: Pathname resolution does not always resolve a symlink.</h4>



<blockquote>

<p>Recommend reject. There is already a note saying essentially that.</p>

</blockquote>



<h4><a name="US47">US 47</a>; 27.10.8.1: “.” and “..” already match the name production. </h4>



<blockquote>

<p> SG recommends that this is not editorial, but we know the fix. Davis Herring 
to supply updated proposed wording.</p>

</blockquote>



<h4><a name="US50">US 50</a>;&nbsp; 27.10.8.3 [path.req]: <code>path</code> 
requirements ¶ 1.4 largely redundant with ¶ 1.3</h4>


<blockquote>

<p>Beman Dawes comments: IIRC, Daniel Krügler 
crafted those two paragraphs for good reason, and so I would not want to make 
any change without consulting him.</p>

<p>Marshall Clow comments: I&#39;m not convinced that this is a defect.</p>

</blockquote>



<h2><a name="late-comments"></a>Late comments from P0489R0</h2>



<p>Quoting P0489R0, &quot;These comments were not submitted in time to 
be registered as National Body Comments, but should be considered as possible 
issues against SC 22, N3151, ISO/IEC CD 14882.&quot; </p>




<p>Late comments 15-47 apply to 27.10 [filesystems]. Except for as noted below, 
this paper recommends new LWG issues be opened for all Late comments related 
to 27.10.</p>

<h4><a name="Late15">Late 15</a>; 27.10.8.4.11 ¶3.1: A “mismatched element” cannot be equal to an iterator</h4>

<h4><a name="Late16">Late 16</a>; 27.10.8.4.11 ¶3.3.1: <code>lexically_relative("..\\foo")</code> produces nonsense.</h4>

<h4><a name="Late17">Late 17</a>; 27.10.8.4.11 ¶3.3.2: Behavior not always 
appropriate</h4>

<h4><a name="Late18">Late 18</a>; 27.10.8.4.11 ¶4: Behavior wrong in case corresponding to  comment Late17</h4>

<h4><a name="Late19">Late 19</a>; 27.10.8.5 ¶2: It is surprising that a path is a container of paths</h4>

<blockquote>

<p>Recommend NAD. See <a href="#US55">US 55</a>, <a href="#US59">US 59</a>.</p>

</blockquote>

<h4><a name="Late20">Late 20</a>; 27.10.11 ¶1: Anemic status structure</h4>

<h4><a name="Late21">Late 21</a>; 27.10.12: <code>directory_entry</code> is just a tivial wrapper for <code>path</code></h4>

<h4><a name="Late22">Late 22</a>; 27.10.13 ¶6: <code>directory_iterator</code> cumbersome to assemble full path with iterator’s directory</h4>

<h4><a name="Late23">Late 23</a>; 27.10.14.1 ¶28: <code>disable_recursion_pending()</code> name is ugly implementation detail</h4>

<h4><a name="Late24">Late 24</a>; 27.10.15.1 ¶1: <code>absolute()</code> can produce nonsense result</h4>

<h4><a name="Late25">Late 25</a>; 27.10.15.4 ¶4.2: What attributes does <code>copy_file()</code> copy?</h4>

<h4><a name="Late26">Late 26</a>; 27.10.15.6 ¶5: <code>create_directories()</code> complexity assumes syscalls take constant time</h4>

<h4><a name="Late27">Late 27</a>; 27.10.15.7 ¶5: <code>create_directory()</code> specification prevents sensible security measures</code></h4>

<h4><a name="Late28">Late 28</a>; 27.10.15.10: <code>create_symlink()</code> might misbehave if <code>to</code> is a directory</h4>

<h4><a name="Late29">Late 29</a>; 27.10.15.13: Access to file ID is superior to <code>equivalent()</code></h4>

<h4><a name="Late30">Late 30</a>; 27.10.15.13 ¶3: <code>equivalent()</code>'s <code>s1==s2</code> check is ill-formed and could race</h4>

<h4><a name="Late31">Late 31</a>; 27.10.15.13 ¶5: Surprising that <code>equivalent()</code>'s error_code overload 
can throw</h4>

<h4><a name="Late32">Late 32</a>; 27.10.15.13 ¶5 : <code>equivalent()</code> should not reject special files outright</h4>

<h4><a name="Late33">Late 33</a>; 27.10.15.21: <code>is_other()</code> result surprising</h4>

<h4><a name="Late34">Late 34</a>; 27.10.15.25 ¶5: Could <code>last_write_time()</code> guarantee the error direction</code></h4>

<blockquote>

<p>Recommend submitting a paper that researches whether this is in fact 
possible. If it is possible, providing proposed wording would be helpful.</p>

</blockquote>

<h4><a name="Late35">Late 35</a>; 27.10.15.26: Why is there no way to read permissions?</h4>

<blockquote>

<p>Recommend NAD. They are available in <code>file_status</code>. If anyone 
thinks a separate function would be useful, they should submit an issue or a 
paper.</p>

</blockquote>

<h4><a name="Late36">Late 36</a>; 27.10.15.26: The <code>permissions() error_code</code> overload should be <code>noexcept</code></h4>

<blockquote>

<p>Recommend accept, unless someone can see something I&#39;m missing.</p>

<p><i>Change 27.10.15.26 [fs.op.permissions] and 27.10.6 Header &lt;filesystem&gt; 
synopsis [fs.filesystem.syn]:</i></p>

  <blockquote>

<p><code>void permissions(const path&amp; p, perms prms, error_code&amp; ec) <ins>noexcept</ins>;</code></p>

  </blockquote>

</blockquote>

<h4><a name="Late37">Late 37</a>; 27.10.15.26 ¶2:<code>permissions()</code> actions should be separate parameter</h4>

<blockquote>

<p>Matt Austern pointed out this issue and its fix for the TS, but it got dropped on the floor in 
the TS shipping rush and has never been fixed. We should probably fix it now or never.</p>  

</blockquote>

<h4><a name="Late38">Late 38</a>; 27.10.15.26 ¶2: Unimplementable implication that <code>permissions()</code> is atomic</h4>

<h4><a name="Late39">Late 39</a>; 27.10.15.29 ¶3: Suprising <code>relative()</code> behavior for symlinks</h4>

<h4><a name="Late40">Late 40</a>; 27.10.15.31 ¶1: <code>remove_all()</code> unclear for <code>symlink/</code></h4>

<h4><a name="Late41">Late 41</a>; 27.10.15.31 ¶3: Would be useful for <code>remove_all()</code> to report successful removal count on error</h4>

<h4><a name="Late42">Late 42</a>; 27.10.15.33 ¶1: <code>resize_file()</code> <i>Postcondition</i> missing argument</h4>

<blockquote>

<p>Recommend accept.</p>

  <blockquote>

<p><i>Change 27.10.15.33 [fs.op.resize_file]:</i></p>

  <blockquote>

<p><i>Postcondition</i>: <code>file_size(<ins>p</ins>) == new_size</code>.</p>

  </blockquote>
  </blockquote>
</blockquote>

<h4><a name="Late43">Late 43</a>; 27.10.15.33 ¶3: Add POSIX <code>ftruncate()</code> equivalent function</h4>

<blockquote>

<p>Recommend opening issue. Such a feature might be useful in 27.9 [file.streams] for C++2x.</p> 

</blockquote>

<h4><a name="Late44">Late 44</a>; 27.10.15.38: <code>system_complete()</code> name inconsistent with similar functions in subclause</h4>

<h4><a name="Late45">Late 45</a>; 27.10.15.38 ¶6: Remove <code>system_complete()</code> unless it can be made reliable</h4>

<h4><a name="Late46">Late 46</a>; 27.10.15.40 ¶2: Question about <code>weakly_canonical()</code> <i>Effects</i></code></h4>

<h4><a name="Late47">Late 47</a>; 27.10.15.40 ¶4: <code>weakly_canonical()</code> suggested caching is incorrect</h4>


<hr>

</body>

</html>