<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style>
 ins  {background-color: #CCFFCC; text-decoration: none;}
 del  {background-color: #FFCACA; text-decoration: none;}
 a    {text-decoration: none;}
</style>
<title>Filesystem NB Comments C++17</title>
</head>

<body>
<table>
<tr>
  <td align="left">Doc. no.:</td>
  <td align="left">D0492R0</td>
</tr>
<tr>
  <td align="left">Date:</td>
  <td align="left">
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2016-11-03<!--webbot bot="Timestamp" endspan i-checksum="12108" --></td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Beman Dawes &lt;bdawes at acm dot org&gt;
</tr>
<tr>
  <td align="left">Audience:</td>
  <td align="left">Library</td>
</tr>
</table>

<h1>Proposed Resolution of C++17  National Body Comments for Filesystem(R0)</h1>

<p>This document proposes resolutions of C++17 National Body Comments from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0488r0.pdf">
P0488R0</a> related to
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4606.pdf">
N4606</a> 27.10 [filesystems]. Late Comments from
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0489r0.pdf">
P0489R0</a> are also considered, in a separate section.</p>

<p>The proposed resolutions in the initial draft of this paper represent only 
the author&#39;s views. They do not necessarily represent the views of the Library 
Working Group (LWG) or the C++ committee. The tentative plan is that they will 
be reviewed and revised 
in Issaquah, first by a small LWG group, then by the full LWG, and then the revised version 
presented to the full committee on Friday.</p>

<p><b><a href="#nb-comments">NB Technical and general comments</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US25">US 25: has_filename() is equivalent to just !empty()</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US31">US 31: Everything is defined in terms of one implicit host system</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US32">US 32: Meaning of 27.10.2.1 unclear</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US33">US 33: Definition of <i>canonical path</i> problematic</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US34">US 34: Are there attributes of a file that are not an aspect of the file system?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US35">US 35: What synchronization is required to avoid a file system race?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US36">US 36: Symbolic links themselves are attached to a directory via (hard) links</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US37">US 37: The term “redundant current directory (dot) elements” is not defined</a><br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US40">US 40: Not all directories have a parent.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US43">US 43: Concerns about <i>encoded character types</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US44">US 44: Definition of path in terms of a string requires leaky abstraction</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US45">US 45: Generic format portability compromised by unspecified root-name</a><br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US46">US 46: <i>filename</i> can be empty so productions for <i>relative-path</i> are redundant</a><br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US48">US 48: Multiple separators are often meaningful in a <i>root-name</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US49">US 49: What does “method of conversion method” mean?</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US51">US 51: Failing to add / when appending empty string prevents useful apps</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US52">US 52: <code>remove_filename()</code> postcondition is not by itself a definition</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US53">US 53: <code>remove_filename()</code>'s name does not correspond to its behavior</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US54">US 54: <code>remove_filename()</code> is broken</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US55">US 55: <code>replace_extension()</code>'s use of <code>path</code> as parameter is inappropriate</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US56">US 56: Remove <code>replace_extension()</code>&#39;s conditional addition of period</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US57">US 57: On Windows, absolute paths will sort in among relative paths</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US58">US 58: <code>parent_path()</code> behavior for root paths is useless</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US59">US 59: <code>filename()</code> returning <code>path</code> for single path components is bizarre</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US60">US 60: <code>path(&quot;/foo/&quot;).filename()==path(&quot;.&quot;)</code> is surprising</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US61">US 61: Leading dots in <code>filename()</code> should not begin an extension</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US62">US 62: It is important that <code>stem()+extension()==filename()</code></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US63">US 63: <code>lexically_normal()</code> inconsistently treats trailing "/" but not &quot;/..&quot; as directory</a><br> 
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US185">US 185: Fold <code>error_code</code> and non-<code>error_code</code> signatures into one signature</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#FI14">FI 14: <tt>directory_entry</tt> comparisons are members</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US73">US 73, CA 2: <i>root-name</i> is effectively implementation defined</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US74">US 74, CA 3: The term “pathname” is ambiguous in some contexts</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US75">US 75, CA 4: Extra flag in path constructors is needed</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US76">US 76, CA 5: <i>root-name</i> definition is over-specified.</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US77">US 77, CA 6: <code>operator/</code> and other appends not useful if arg has <i>root-name</i></a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US78">US 78, CA 7: Member <code>absolute()</code> in 27.10.4.1 is overspecified for non-POSIX-like O/S</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US79">US 79, CA 8: Some  operation functions are overspecified for implementation-defined file types</a><br>
<b><a href="#editorial">NB comments submitted as editorial</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US38">US 38: Duplicates §17.3.16</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US39">US 39: Remove note: Dot and dot-dot are not directories</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US41">US 41: The term “parent directory” for a (non-directory) file is unusual</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US42">US 42: Pathname resolution does not always resolve a symlink</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US47">US 47: “.” and “..” already match the name production</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#US50">US 50: 27.10.8.1 ¶ 1.4 largely redundant with ¶ 1.3</a><br>
<b>
<a href="#late-comments">Late comments</a></b>

<h2><a name="nb-comments"></a>NB Technical and general comments</h2>

<h4><a name="US25">US 25</a>; 27.10.8.4.10 [path.query]: <code>has_filename()</code> is equivalent to just 
<code>!empty()</code></h4>
<blockquote>
<p>No Proposed wording. Is the real issue a possibly incorrect post-condition for remove filename()? 
Can the submitter provide clarification?</p>

</blockquote>

<h4><a name="US31">US 31</a>; 27.10 [filesystems]: Everything is defined in terms of one implicit host system</h4>
<blockquote>
<p>That&#39;s by design, aimed at achieving portable syntax and portable behavior. 
And that objective has been largely achieved in practical real-world use for 
many years.&nbsp; </p>

<p>Recommend reject. No proposed wording. </p>

</blockquote>

<h4><a name="US32">US 32</a>; 27.10.2.1 [fs.conform.9945] ¶3: Meaning of POSIX 
conformance unclear</h4>

<blockquote>

<p dir="ltr">The comment and its request to &quot;Clarify that ¶2 governs and an 
error must be reported in such cases&quot; might be satisfied by this change:</p>

<p dir="ltr"><i>Change 27.10.2.1 [fs.conform.9945] ¶2:</i></p>
  <blockquote>
    <p>Implementations are not required to provide behavior that is not 
    supported by a particular file system. [ Example: The FAT file system used 
    by some memory cards, camera memory, and floppy disks does not support hard 
    links, symlinks, and many other features of more capable file systems, so 
    implementations are not required to support those features on the FAT file 
    system <ins>but instead are required to report an error as described above</ins>. —end example ]</p>
  </blockquote>
</blockquote>
<h4><a name="US33">US 33</a>; 27.10.4.2 [fs.def.canonical.path]: Definition of <i>canonical path</i> problematic</h4>
<blockquote>
<p>The comment appears to be correct in that the definition of canonical path is 
not used in the WP.</p>
<p><i>Remove 27.10.4.2 [fs.def.canonical.path].</i></p>
</blockquote>
<h4><a name="US34">US 34</a>; 27.10.4.5 [fs.def.filesystem]: Are there attributes of a file that are not an aspect of the file system?</h4>
<blockquote>
<p><i>Change 27.10.4.5 [fs.def.filesystem]:</i></p>
  <blockquote>
<p>A collection of files and certain of their attributes<ins>, including access permissions and type</ins>.</p>
  </blockquote>
<p>The proposed wording is taken directly from POSIX 3.164 <i>File</i> 
definition.</p>
</blockquote>
<h4><a name="US35">US 35</a>; 27.10.4.6 [fs.def.race]: What synchronization is required to avoid a file system race?</h4>
<blockquote>
<p>27.10.4 Terms and definitions [fs.definitions] is not the proper place to 
describe file system race behavior. 27.10.2.3 File system race behavior [fs.race.behavior] 
would be the proper place. The standards committee in general and the SG3 
Filesystem Study Group in particular has long had an outstanding request for 
someone to submit a paper proposing facilities that could be used to minimize 
file system races. No such proposal has been made.</p>
<p>Recommend reject; no consensus at this time. (i.e. NAD, Future)</p>
</blockquote>
<h4><a name="US36">US 36</a>; 27.10.4.9 [fs.def.link]: Symbolic links themselves are attached to a directory via (hard) links</h4>
<blockquote>
<p>Recommend reject. No proposed wording. The current definition is taken 
directly from POSIX 3.130 <i>Directory Entry (or Link)</i> definition.</p>
</blockquote>
<h4><a name="US37">US 37</a>; 27.10.4.12 [fs.def.normal.form]: The term “redundant current directory (dot) elements” is not defined</h4>
<blockquote>
<p>Recommend reject. No proposed wording. &quot;redundant&quot; is used several places in 
the current definition, always in the normal English sense of the word. Detailed 
behavior is specified for individual functions rather than in the definition of 
normal form.</p>
</blockquote>
<h4><a name="US40">US 40</a>; 27.10.4.15 [fs.def.parent]: Not all directories 
have a parent</h4>

<blockquote>
<p>Recommend reject.&nbsp;No proposed wording. The definition in question is taken directly from 
the POSIX
<font face="Times New Roman">§</font>3.268 <i>Parent Directory</i> definition.</p>

</blockquote>

<h4><a name="US43">US 43</a>; 27.10.5 [fs.req] ¶4: Concerns about <i>encoded character types</i></h4>

<blockquote>

<p>&nbsp;No proposed wording. Might be clearer if we changed 27.10.5 
Requirements [fs.req] ¶4:</p>

  <blockquote>

<p>Note: Use of an encoded character type implies an associated <ins>character set and</ins> encoding.
Since <code>signed char</code> and <code>unsigned char</code> have 
no implied <ins>character set and</ins> encoding, they are not included as permitted types. 
—end note ]</p>

  </blockquote>

</blockquote>

<h4><a name="US44">US 44</a>; 27.10.8 [class.path]: Definition of path in terms of a string requires leaky abstraction</h4>
<blockquote>
<p>Recommend reject. No proposed wording. The <i>Proposed change</i> amounts to 
a redesign and rewrite of the class path specification. Such an extensive change 
would require a separate proposal including proposed wording, not to mention 
implementation and user experience.</p>

</blockquote>

<h4><a name="US45">US 45</a>; 27.10.8.1 [path.generic]: Generic format portability compromised by unspecified 
<i>root-name</i></h4>
<blockquote>
<p>Recommend reject. No proposed wording. <i>root-name</i> is specified in the 
grammar given in [path.generic] as operating system dependent, and that 
specification includes a note explaining the rationale of this design choice. </p>

</blockquote>

<h4><a name="US46">US 46</a>; 27.10.8.1 [path.generic]: <i>filename</i> can be empty so productions for <i>relative-path</i> are redundant</h4>
<blockquote>
<p>No proposed wording. Need help from BNF grammar experts.</p>

</blockquote>

<h4><a name="US48">US 48</a>; 27.10.8.1 [path.generic] ¶1: Multiple separators are often meaningful in a <i>root-name</i></h4>
<blockquote>
<p>Recommend accept with modifications. </p>

<p><i>Change 27.10.8.1 [path.generic] ¶1:</i></p>

  <blockquote>
<p><ins>Except in <i>root-name</i>, m</ins><del>M</del>ultiple successive <i>
directory-separator</i> characters are considered to be the same as one <i>
directory-separator </i>character.</p>

  </blockquote>
</blockquote>

<h4><a name="US49">US 49</a>; 27.10.8.2.2 [path.type.cvt]: What does “method of conversion method” mean?</h4>
<blockquote>
<p>Recommend accept with modifications.</p>

<p><i>Change 27.10.8.2.2 [path.type.cvt]:</i></p>

  <blockquote>
    <ul>
      <li><i>¶1.2:</i> method of conversion <del>method</del> is unspecified</li>
      <li><i>¶1.3:</i> method of conversion <del>method</del> is unspecified</li>
      <li><i>¶1.4:</i> method of conversion <del>method</del> is unspecified</li>
    </ul>
  </blockquote>
</blockquote>

<h4><a name="US51">US 51</a>; 27.10.8.4.3 [path.append] ¶2.3: Failing to add / when appending empty string prevents useful apps</h4>
<blockquote>
<p>Not clear  why <code>p /= "/"</code> would not be satisfactory,
unless there is concern
that code like <code>p /= some_string</code> might not work as intended if <code>some_string</code> 
is empty. Clarification from comment submitter would be helpful.</p>

</blockquote>

<h4><a name="US52">US 52</a>; 27.10.8.4.5 [path.modifiers] ¶5: <code>remove_filename()</code> postcondition is not by itself a definition</h4>
<blockquote>
<p>Recommend accept with modifications.</p>
<p>
<i>Change 27.10.8.4.5 [path.modifiers] ¶5:</i> </p>
<blockquote>
<h4>
<span style="font-weight: 400">
<i>Postcondition:</i> <del><code>!has_filename()</code></del>
<ins>For an object <code>p</code> of type <code>path</code>,
<code>p.remove_filename().has_filename() == false</code></ins>. </span>
</blockquote>
</blockquote>

<h4><a name="US53">US 53</a>; 27.10.8.4.5 [path.modifiers] ¶7: <code>remove_filename()</code>'s name does not correspond to its behavior</h4>

<blockquote>

<p>This issue probably needs to be resolved before C++17 ships, since a name 
change is a breaking change.</p>
<p>Bikeshed:
<code>remove_last_element()</code> rather than the suggested <code>remove_component()</code>.<p>
  <b>Caution:</b> &quot;remove_filename&quot; appears at least seven times in the 
  standard. All will need to be changed if the name changes.<p><b>Caution:</b> &quot;replace_filename&quot; 
  presumably also would need to be renamed.</blockquote>

<h4><a name="US54">US 54</a>; 27.10.8.4.5 [path.modifiers] ¶10: <code>remove_filename()</code> is broken</h4>

<blockquote>

<p>Need to resolve <a href="#US53">US 53</a> first.</p>

</blockquote>

<h4><a name="US55">US 55</a>; 27.10.8.4.5 [path.modifiers] ¶11: <code>replace_extension()</code>'s use of <code>path</code> as parameter is inappropriate</h4>

<blockquote>
<p>Option A: Very strongly recommend rejection. <code>path</code> is the filesystem
library's vocabulary type for both fully formed paths and for path fragments. Changing
the vocabulary type for path fragments to <code>string_type</code>, as suggested in this
NB comment, would make it more difficult to write code that is portable between operating systems
that use different <code>string_type</code>s (i.e. between POSIX and Windows).
For example, <code>p.replace_extension(".txt")</code> would work on POSIX but fail to compile on Windows. 
It would also make code more difficult that must deal with character encodings that differ
from the operating system's expected encoding for <code>string_type</code>. As written, this is a
"strongly against" issue for me.

<p>Option B: An alternative view of US 55 might be that there is a defect in the clarity of 27.10.8 [class.path] ¶1. Perhaps
it should be changed something like this:</p>

<blockquote>
<p>An object of class path represents a path (27.10.4.17) <ins>or a portion of a path</ins>
 and contains a pathname (27.10.4.18) <ins>or a portion of a pathname</ins>. Such an object
is concerned only with the lexical and syntactic aspects of a path. The path does not necessarily exist in
external storage, and the pathname is not necessarily valid for the current operating system or for a particular
file system.</p>

<p><ins>[<i>Note:</i> Class path is used to hide the difference between the string types
 used by different operating systems to represent pathnames. &mdash; <i>end note</i>]</ins></p>

</blockquote>
 
</blockquote>
 
<h4><a name="US56">US 56</a>; 27.10.8.4.5 [path.modifiers] ¶11.2: Remove <code>
replace_extension()</code>&#39;s conditional addition of period</h4>

<blockquote>
 
<p>An example of where the current behavior is useful: <code>
path(&quot;my_file.tx&quot;).replace_extension(&quot;txt&quot;)</code></p>

<p>An example of a case where the current behavior is unsatisfactory would be 
helpful.</p>

<p>Recommend reject. Insufficient motivation for change.</p>

</blockquote>

<h4><a name="US57">US 57</a>; 27.10.8.4.8 [path.compare] ¶2: On Windows, absolute paths will sort in among relative paths</h4>

<blockquote>

<p>It isn&#39;t clear why this matters; an example would help.</p>

<p>Recommend reject. No proposed wording. Insufficient motivation for change.
  </p>

</blockquote>

<h4><a name="US58">US 58</a>; 27.10.8.4.9 [path.decompose] ¶5: <code>parent_path()</code> behavior for root paths is useless</h4>

<blockquote>

<p>The example given (<code>path(&quot;c:\\&quot;).parent_path()</code> on 
Windows returns <code>path(&quot;c:&quot;)</code>) seems useful. </p>

<p>Recommend reject. No proposed wording. Insufficient motivation for change.</p>

</blockquote>

<h4><a name="US59">US 59</a>; 27.10.8.4.9 [path.decompose] ¶6: <code>filename()</code> returning <code>path</code> for single path components is bizarre</h4>

<blockquote>

<p>Recommend reject. <code>path</code> is filesystem's
vocabulary type for both full paths and for path components, in the same sense that
<code>std::string</code> might be used as the vocabulary type for both sentences and 
the words in the
sentences. See <a href="#US55">US 55</a> for further discussion.</p>

</blockquote>

<h4><a name="US60">US 60</a>; 27.10.8.4.9 [path.decompose] ¶6: <code>path(&quot;/foo/&quot;).filename()==path(&quot;.&quot;)</code> is surprising</h4>

<blockquote>

<p>If this is really a comment about 27.10.8.4.9 [path.decompose] ¶6 then it 
should be rejected, because that paragraph (<i>Returns</i>: <code>empty() ? 
path() : *--end()</code>.) is correct.</p>

<p>Perhaps the comment is really a request to strike 27.10.8.5 path iterators [path.itr]
¶ 4.4:</p>

  <blockquote>

<p><del>&mdash; <i>dot</i>, if one or more trailing non-root <i>
slash</i> characters are present.</del></p>

  </blockquote>

<p>That iterator behavior has always been surprising and controversial. But such 
a change would require a paper revisiting the original motivation (i.e. 
reflecting the presence of a trailing slash indicating a directory path, which 
is important for non-POSIX/Windows, and ensuring that reconstruction by 
iteration yields the same path as the original for some definition of &quot;same&quot;), 
exploring how the change would ripple through class path, what the alternatives 
are, and so forth.</p>

<p>Recommend reject, but open an LWG issue to leave the door open for such a 
paper.</p>

</blockquote>

<h4><a name="US61">US 61</a>; 27.10.8.4.9 [path.decompose] ¶8: Leading dots in <code>filename()</code> should not begin an extension</h4>

<blockquote>

<p>Cases that seem worth considering, with suggested decompositions:</p>

<blockquote>

  <table border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111">
    <tr>
      <td><i><b><code>path p</code></b></i></td>
      <td><i><b><code>p.stem()</code></b></i></td>
      <td><i><b><code>p.extension()</code></b></i></td>
    </tr>
    <tr>
      <td><code>&quot;.bashrc&quot;</code></td>
      <td><code>&quot;.bashrc&quot;</code></td>
      <td>&quot;&quot;</td>
    </tr>
    <tr>
      <td><code>&quot;..abc&quot;</code></td>
      <td><code>&quot;..abc&quot;</code></td>
      <td>&quot;&quot;</td>
    </tr>
    <tr>
      <td>&quot;<code>...abc</code>&quot;</td>
      <td>&quot;<code>...abc</code>&quot;</td>
      <td>&quot;&quot;</td>
    </tr>
    <tr>
      <td>&quot;<code>abc..def</code>&quot;</td>
      <td>&quot;<code>abc</code>&quot;</td>
      <td>&quot;<code>..def</code>&quot;</td>
    </tr>
    <tr>
      <td>&quot;<code>abc...def</code>&quot;</td>
      <td>&quot;<code>abc</code>&quot;</td>
      <td>&quot;<code>...def</code>&quot;</td>
    </tr>
  </table>
</blockquote>

<p><i>Change 27.10.8.4.9 [path.decompose] ¶ 8:</i></p>

<blockquote>

<p><code>path stem() const;</code></p>

  <blockquote>

<p><i>Returns:</i> if <code>filename()</code> contains a period <del>but does not 
consist solely of one or two periods</del> <ins>other than in a sequence of one or 
more beginning periods</ins>, returns the substring of <code>filename()</code> 
starting at its beginning and ending with the character before the <del>last period</del> <ins>
first period of the last sequence of one or more periods</ins>.
Otherwise, returns <code>filename()</code>.</p>

  </blockquote>
</blockquote>

<p><i>Change 27.10.8.4.9 [path.decompose] ¶ 10:</i></p>

<blockquote>

<p><code>path extension() const;</code></p>

  <blockquote>

<p><i>Returns:</i> if <code>filename()</code> contains a period <del>but does not 
consist solely of one or two periods</del> <ins>other than in a sequence of one or 
more beginning periods</ins>, returns the substring of <code>filename()</code> 
starting at <ins>the beginning of</ins> the rightmost <ins>sequence of</ins> period<ins>s</ins> and for the remainder of the path. Otherwise, 
returns an empty <code>path</code> object.</p>

  </blockquote>
</blockquote>

</blockquote>

<h4><a name="US62">US 62</a>; 27.10.8.4.9 [path.decompose] ¶11: It is important that <code>stem()+extension()==filename()</code></h4>

<blockquote>

<p>Yes, it is important. But the note in ¶11 already says exactly that, so
the question becomes "Should we make that part of the note normative?"</p>

</blockquote>

<h4><a name="US63">US 63</a>; 27.10.8.4.11 ¶1: <code>lexically_normal()</code> inconsistently treats trailing "/" but not &quot;/..&quot; as directory</h4>

<blockquote>

<p>Need proposed wording for the <i>Proposed change</i> "Append the /. in all cases known to name directories (if it is in fact necessary)".</p>

</blockquote>

<h4><b><a name="US185">US 185</a>; 27.10.7: </b>Fold <code>error_code</code> and non-<code>error_code</code> signatures into one signature</h4>

<blockquote>

<p>Recommend reject.</p>

<p> Does not handle one signature being <code>
noexcept(true)</code> and the other <code>noexcept(false)</code>, and many other 
problems. Even the submitter is no longer in favor. See LWG list thread 
&quot;[filesystem] US-185 Eliminating dual signatures for operational functions&quot;, 
October 25, 2016.</p>

</blockquote>

<h4><a name="FI 14">FI 14</a>; 27.10.12.3: <tt>directory_entry</tt> comparisons are members</h4>



<blockquote>

<p>Recommend reject.</p>

<p>This is LWG issue
<a href="http://cplusplus.github.io/LWG/lwg-closed.html#2761">2761</a>, which 
has been closed as NAD. </p>

</blockquote>



<h4><a name="US73">US 73</a>, CA 2; 27.10.8.1 [path.generic]: <i>root-name</i> is effectively implementation defined</h4>

<blockquote>

<p>The comment&#39;s proposed wording is to replace &quot;operating system dependent&quot; 
with &quot;implementation defined path prefix&quot;. </p>

<p>The comment&#39;s premise that &quot;<i>root-name</i> is effectively implementation defined&quot; 
is not correct. See 27.10.2.2 [fs.conform.os] and 27.10.4.14 [fs.def.osdep].</p>

<p>&quot;operating system dependent&quot; mandates different implementations for the same 
operating system produce the same behavior, but &quot;implementation defined&quot; allows 
different implementations for the same operating system to produce different 
behavior.</p>

<p>Recommend reject. </p>

</blockquote>

<h4><a name="US74">US 74</a>, CA 3; 27.10.8 [class.path]: The term “pathname” is ambiguous in some contexts</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> Section 2.1</p>

</blockquote>

<h4><a name="US75">US 75</a>, CA 4; 27.10.8.4.1 [path.construct]: Extra flag in path constructors is needed</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.2</p>

</blockquote>

<h4><a name="US76">US 76</a>, CA 5; 27.10.8.1 [path.generic]: <i>root-name</i> definition is over-specified.</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.3.1</p>

</blockquote>

<h4><a name="US77">US 77</a>, CA 6; 27.10.8.4.3 [path.append]: <code>operator/</code> and other appends not useful if arg has <i>root-name</i></h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.3.2</p>

</blockquote>

<h4><a name="US78">US 78</a>, CA 7; 27.10.15.1 [fs.op.absolute]: Member <code>absolute()</code> in 27.10.4.1 is overspecified for non-POSIX-like O/S</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.4.1</p>

</blockquote>

<h4><a name="US79">US 79</a>, CA 8; Several: Some  operation functions are overspecified for implementation-defined file types</h4>

<blockquote>

<p>Also see 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0430r0.pdf">P0430R0</a> 
Section 2.4.2</p>

</blockquote>



<h2><a name="editorial"></a>NB  comments submitted as editorial</h2>





<p>It isn&#39;t at all clear than any of these are really editorial. A ruling by the 
project editor is probably needed.</p>





<h4><a name="US38">US 38</a>; 27.10.4.13 [fs.def.symlink]:&nbsp; Duplicates §17.3.16.</h4>



<blockquote>

<p> Recommend reject. 27.10.4.13 provides additional wording&nbsp;not 
present in 17.3.16. </p>

</blockquote>



<h4><a name="US39">US 39</a>; 27.10.4.15: Remove note: Dot and dot-dot are not directories. </h4>



<blockquote>

<p> Recommend reject. The note was added to resolve confusion over dot and 
dot-dot.</p>

</blockquote>



<h4><a name="US41">US 41</a>; 27.10.4.16: The term “parent directory” for a (non-directory) file is unusual. </h4>


<blockquote>
<p>Recommend reject. Insufficient motivation for change. &quot;parent directory&quot; is the 
term we use to describe the containing directory, and to change that would imply 
changing at least one function name.</p>
</blockquote>

<h4><a name="US42">US 42</a>; 27.10.4.21: Pathname resolution does not always resolve a symlink.</h4>



<blockquote>

<p>Recommend reject. There is already a note saying essentially that.</p>

</blockquote>



<h4><a name="US47">US 47</a>; 27.10.8.1: “.” and “..” already match the name production. </h4>



<blockquote>

<p> This may well be an issue, but likely substantive rather than editorial.</p>

</blockquote>



<h4><a name="US50">US 50</a>;&nbsp; 27.10.8.3 [path.req]: <code>path</code> 
requirements ¶ 1.4 largely redundant with ¶ 1.3</h4>


<blockquote>

<p>Beman Dawes comments: IIRC, Daniel Krügler 
crafted those two paragraphs for good reason, and so I would not want to make 
any change without consulting him.</p>

<p>Marshall Clow comments: I&#39;m not convinced that this is a defect.</p>

</blockquote>



<h2><a name="late-comments"></a>Late comments from P0489R0</h2>



<p>Quoting P0489R0, &quot;These comments were not submitted in time to 
be registered as National Body Comments, but should be considered as possible 
issues against SC 22, N3151, ISO/IEC CD 14882.&quot; </p>




<p>Late comments 15-47 apply to 27.10 [filesystems]. Except for as noted below, 
this paper recommends new LWG issues be opened for all Late comments related 
to 27.10.</p>

<h4><a name="Late15">Late 15</a>; 27.10.8.4.11 ¶3.1: A “mismatched element” cannot be equal to an iterator</h4>

<h4><a name="Late16">Late 16</a>; 27.10.8.4.11 ¶3.3.1: <code>lexically_relative("..\\foo")</code> produces nonsense.</h4>

<h4><a name="Late17">Late 17</a>; 27.10.8.4.11 ¶3.3.2: Behavior not always 
appropriate</h4>

<h4><a name="Late18">Late 18</a>; 27.10.8.4.11 ¶4: Behavior wrong in case corresponding to  comment Late17</h4>

<h4><a name="Late19">Late 19</a>; 27.10.8.5 ¶2: It is surprising that a path is a container of paths</h4>

<h4><a name="Late20">Late 20</a>; 27.10.11 ¶1: Anemic status structure</h4>

<h4><a name="Late21">Late 21</a>; 27.10.12: <code>directory_entry</code> is just a tivial wrapper for <code>path</code></h4>

<h4><a name="Late22">Late 22</a>; 27.10.13 ¶6: <code>directory_iterator</code> cumbersome to assemble full path with iterator’s directory</h4>

<h4><a name="Late23">Late 23</a>; 27.10.14.1 ¶28: <code>disable_recursion_pending()</code> name is ugly implementation detail</h4>

<h4><a name="Late24">Late 24</a>; 27.10.15.1 ¶1: <code>absolute()</code> can produce nonsense result</h4>

<h4><a name="Late25">Late 25</a>; 27.10.15.4 ¶4.2: What attributes does <code>copy_file()</code> copy?</h4>

<h4><a name="Late26">Late 26</a>; 27.10.15.6 ¶5: <code>create_directories()</code> complexity assumes syscalls take constant time</h4>

<h4><a name="Late27">Late 27</a>; 27.10.15.7 ¶5: <code>create_directory()</code> specification prevents sensible security measures</code></h4>

<h4><a name="Late28">Late 28</a>; 27.10.15.10: <code>create_symlink()</code> might misbehave if <code>to</code> is a directory</h4>

<h4><a name="Late29">Late 29</a>; 27.10.15.13: Access to file ID is superior to <code>equivalent()</code></h4>

<h4><a name="Late30">Late 30</a>; 27.10.15.13 ¶3: <code>equivalent()</code>'s <code>s1==s2</code> check is ill-formed and could race</h4>

<h4><a name="Late31">Late 31</a>; 27.10.15.13 ¶5: Surprising that <code>equivalent()</code>'s error_code overload 
can throw</h4>

<h4><a name="Late32">Late 32</a>; 27.10.15.13 ¶5 : <code>equivalent()</code> should not reject special files outright</h4>

<h4><a name="Late33">Late 33</a>; 27.10.15.21: <code>is_other()</code> result surprising</h4>

<h4><a name="Late34">Late 34</a>; 27.10.15.25 ¶5: Could <code>last_write_time()</code> guarantee the error direction</code></h4>

<h4><a name="Late35">Late 35</a>; 27.10.15.26: Why is there no way to read permissions?</h4>

<h4><a name="Late36">Late 36</a>; 27.10.15.26: The <code>permissions() error_code</code> overload should be <code>noexcept</code></h4>

<h4><a name="Late37">Late 37</a>; 27.10.15.26 ¶2:<code>permissions()</code> actions should be separate parameter</h4>

<blockquote>

<p>Beman comments: Matt Austern pointed out this issue and its fix, but it got dropped on the floor in Filesystem TS shipping rush and has never been fixed. We should fix it now or never.</p>  

</blockquote>

<h4><a name="Late38">Late 38</a>; 27.10.15.26 ¶2: Unimplementable implication that <code>permissions()</code> is atomic</h4>

<h4><a name="Late39">Late 39</a>; 27.10.15.29 ¶3: Suprising <code>relative()</code> behavior for symlinks</h4>

<h4><a name="Late40">Late 40</a>; 27.10.15.31 ¶1: <code>remove_all()</code> unclear for <code>symlink/</code></h4>

<h4><a name="Late41">Late 41</a>; 27.10.15.31 ¶3: Would be useful for <code>remove_all()</code> to report successful removal count on error</h4>

<h4><a name="Late42">Late 42</a>; 27.10.15.33 ¶1: <code>resize_file()</code> <i>Postcondition</i> missing argument</h4>

<blockquote>

<p><i>Change 27.10.15.33 [fs.op.resize_file]:</i></p>

  <blockquote>

<p><i>Postcondition</i>: <code>file_size(<ins>p</ins>) == new_size</code>.</p>

  </blockquote>
</blockquote>

<h4><a name="Late43">Late 43</a>; 27.10.15.33 ¶3: Add POSIX <code>ftruncate()</code> equivalent function</h4>

<blockquote>

<p>Recommend opening issue. Such a feature might be useful in 27.9 [file.streams] for C++20.</p> 

</blockquote>

<h4><a name="Late44">Late 44</a>; 27.10.15.38: <code>system_complete()</code> name inconsistent with similar functions in subclause</h4>

<h4><a name="Late45">Late 45</a>; 27.10.15.38 ¶6: Remove <code>system_complete()</code> unless it can be made reliable</h4>

<h4><a name="Late46">Late 46</a>; 27.10.15.40 ¶2: Question about <code>weakly_canonical()</code> <i>Effects</i></code></h4>

<h4><a name="Late47">Late 47</a>; 27.10.15.40 ¶4: <code>weakly_canonical()</code> suggested caching is incorrect</h4>


<hr>

</body>

</html>