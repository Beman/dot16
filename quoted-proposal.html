<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>&quot;quoted&quot; proposal</title>
  <meta name="generator" content="Microsoft FrontPage 5.0" />
<style type="text/css">
body  {
        font-family: sans-serif;
        margin: 1em;
        max-width : 7.5in;
      }

table { margin: 0.5em; }

pre   { background-color:#D7EEFF }

ins   { background-color:#CCFFCC }
del   { background-color:#FFCACA }

  </style>
</head>

<body>

  <table border="0" height="107">
    <tr>
      <td height="23">Document number:&nbsp;&nbsp; </td>
      <td height="23"><span style="background-color: #FFFF8C">Draft</span></td>
    </tr>
    <tr>
      <td height="23">Date:</td>
      <td height="23">
      <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y-%m-%d" startspan -->2013-03-13<!--webbot bot="Timestamp" endspan i-checksum="12181" --></td>
    </tr>
    <tr>
      <td height="23">Project:</td>
      <td height="23">Programming Language C++</td>
    </tr>
    <tr>
      <td valign="top" height="22">Reply-to:</td>
      <td height="22">Beman Dawes &lt;bdawes at acm dot org&gt;</td>
    </tr>
  </table>


<h1>Quoted Strings Library Proposal (Revision 1)</h1>


<h2><a name="Introduction">Introduction</a></h2>


<p>Character strings enclosed in quotation marks are a common data format (e.g. 
XML, CSV), yet C++ standard library stream I/O offers no direct support and has 
a problem with strings that can trip the unwary. The proposed solution provides 
direct support for quoted strings, and does so in a more efficient manner than 
is likely with roll-your-own solutions</p>


<p>The proposed is suitable for either C++1y or a standard library Technical Specification 
(TS). It 
is a pure addition that will 
break no existing user code, assuming disciplined use of namespaces. It is based on 
Boost code that has been shipping for several years, but has not yet been 
formally reviewed. The declarations of new functions can go in a new header, or 
in an existing header.</p>


<p>The proposed wording below assumes the target is C++1y and places the 
function declarations in &lt;iomanip&gt;.</p>


<h2><a name="Problem">Problem</a> description</h2>
<p>C++ standard library stream I/O for strings that contain embedded spaces 
can produce unexpected results. For example,</p>
<blockquote>
  <pre>std::stringstream ss;
std::string original = &quot;foolish me&quot;;
std::string round_trip;

ss &lt;&lt; original;
ss &gt;&gt; round_trip;

std::cout &lt;&lt; original;   // outputs: foolish me
std::cout &lt;&lt; round_trip; // outputs: foolish

assert(original == round_trip); // assert will fire</pre>
</blockquote>
<p>The proposed <code>quoted</code> stream I/O manipulator places delimiters, defaulted 
to 
double-quote (<code>&quot;</code>), around strings on output, and strips off 
the delimiters on input. This ensures strings with embedded white space round-trip as 
desired. For example,</p>
<blockquote>
  <pre>std::stringstream ss;
std::string original = &quot;foolish me&quot;;
std::string round_trip;

ss &lt;&lt; quoted(original);
ss &gt;&gt; quoted(round_trip);

std::cout &lt;&lt; original;     // outputs: foolish me
std::cout &lt;&lt; round_trip;   // outputs: foolish me

assert(original == round_trip); // assert will not fire</pre>
</blockquote>
<p>If the string contains the delimiter character, on output that character will 
be preceded by an escape character, default to backslash (<code>\</code>), as will the escape character itself:</p>
<blockquote>
  <pre>std::cout &lt;&lt; quoted(&quot;She said \&quot;Hi!\&quot;&quot;);  // outputs: &quot;She said \&quot;Hi!\&quot;&quot;</pre>
</blockquote>


<h2><a name="Revision-history">Revision history</a></h2>


<p><span style="background-color: #FFFF8C">Nxxxx</span> - Revision 1 
(pre-Bristol mailing)</p>
  <ul>
    <li>Remove unnecessary backslash from character literals in default arguments.</li>
    <li>Add semantics for non-member functions.</li>
    <li>Add specifics of stream insertion and extraction, with reference to the 
    standard, so that error handling is well-specified.</li>
  </ul>


  <p>
  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3431.html">
  N3431</a> Initial paper (pre-Portland mailing)</p>
<h2><a name="Proposed-wording">Proposed wording</a></h2>
<p><i>Change 27.7.1 Overview [iostream.format.overview], &quot;Header &lt;iomanip&gt; 
synopsis&quot; as indicated:</i></p>
  <blockquote>
    <pre>namespace std {
// <i>types</i> T1, T2, ... <i>are unspecified implementation types</i>
<i>T1</i> resetiosflags(ios_base::fmtflags mask);
<i>T2</i> setiosflags (ios_base::fmtflags mask);
<i>T3</i> setbase(int base);
template&lt;charT&gt; <i>T4</i> setfill(charT c);
<i>T5</i> setprecision(int n);
<i>T6</i> setw(int n);
template &lt;class moneyT&gt; <i>T7</i> get_money(moneyT&amp; mon, bool intl = false);
template &lt;class moneyT&gt; <i>T8</i> put_money(const moneyT&amp; mon, bool intl = false);
template &lt;class charT&gt; <i>T9</i> get_time(struct tm* tmb, const charT* fmt);
template &lt;class charT&gt; <i>T10</i> put_time(const struct tm* tmb, const charT* fmt);

<ins>template &lt;class charT, class traits, class Allocator&gt;</ins>
  <ins><i>T11</i> quoted(const std::basic_string&lt;charT, traits, Allocator&gt;&amp; s,</ins>
             <ins>charT delim='&quot;', charT escape='\\');</ins>

<ins>template &lt;class charT&gt;</ins>
  <ins><i>T12</i> quoted(const charT* s, charT delim='&quot;', charT escape='\\');</ins>

<ins>template &lt;class charT, class traits, class Allocator&gt;</ins>
  <ins><i>T13</i> quoted(std::basic_string&lt;charT, traits, Allocator&gt;&amp; s,</ins>
             <ins>charT delim='&quot;', charT escape='\\');</ins>
}</pre>
  </blockquote>
<p>After 27.7.5 Extended manipulators [ext.manip], add a new sub-section:</p>
  <blockquote>
<p>27.7.6 Quoted manipulators [quoted.manip]</p>
    <pre>template &lt;class charT, class traits, class Allocator&gt;
<i>unspecified</i> quoted(const std::basic_string&lt;charT, traits, Allocator&gt;&amp; s,
                   charT delim='&quot;', charT escape='\\');
template &lt;class charT, class traits, class Allocator&gt;
<i>unspecified</i> quoted(const charT* s, charT delim='&quot;', charT escape='\\');</pre>
    <blockquote>
<p><i>Returns:</i> An object of unspecified type such that if <code>out</code> 
is an instance of <code>basic_ostream&lt;charT,<br>
traits&gt;</code>, <code>s</code> is an instance of a type convertible to <code>std::basic_string&lt;charT, traits, Allocator&gt;</code>, 
or <code>const char*</code>, respectively,
<code>delim</code> and <code>escape</code> are instances of types convertible to
<code>charT</code>, then the expression <code>out &lt;&lt; quoted(s, delim, escape)</code> 
behaves as if it inserts the following characters into <code>out</code> using character inserter function templates ([ostream.inserters.character]), 
which may throw <code>ios_base::failure</code> ([ios::failure])</p>
  <ul>
    <li><code>delim</code>.</li>
    <li>Each character in <code>s</code>. If the character to be output is 
    equal to <code>escape</code> or <code>delim</code>, as determined by <code>
    operator==</code>, first output <code>escape</code>. </li>
    <li><code>delim</code>.</li>
  </ul>
<p>and then returns a reference to <code>out</code>.</p>
<p>The expression <code>out &lt;&lt; quoted(s, delim, escape)</code> shall have type
<code>basic_ostream&lt;charT, traits&gt;&amp;</code> and value <code>out</code>.</p>
    </blockquote>
  </blockquote>
<h3>Requirements for implementation supplied types [quoted.imp]</h3>
<p>[<i>Note:</i> The implementation supplied types serve as proxies for the
<code>quoted</code> function arguments, allowing implementations to avoid 
construction of temporary strings. <i>-- end note</i>] </p>
<p><i><b><code>implementation-type1</code></b></i> 
and <i><b><code>implementation-type</code></b></i><code><b><i>2</i></b></code> are implementation supplied 
types with implementation supplied <code>operator&lt;&lt;</code>:</p>
<blockquote>
  <pre>template &lt;class charT, class traits&gt;
  std::basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(std::basic_ostream&lt;charT, traits&gt;&amp; os, const <i><b><code>implementation-typeN</code></b></i>&amp; proxy);</pre>
<p><i>Effects:</i> <ins>Using character inserter function templates ([ostream.inserters.character]), 
which may throw <code>ios_base::failure</code> ([ios::failure]),</ins> inserts characters into <code>os</code>:</p>
  <ul>
    <li><code>delim</code>.</li>
    <li>Each character in <code>string</code>. If the character to be output is 
    equal to <code>escape</code> or <code>delim</code>, as determined by <code>
    operator==</code>, first output <code>escape</code>. </li>
    <li><code>delim</code>.</li>
  </ul>
<p><i>Remarks:</i> <code>string</code>, <code>escape</code>, and <code>delim</code> 
have the type and value of the corresponding arguments of the call to the <code>
quoted</code> function that constructed <code>proxy</code>.</p>
<p><i>Returns:</i> <code>os</code>. </p>
</blockquote>
<p><i><b><code>implementation-type3</code></b></i> is an implementation supplied 
type with an implementation supplied <code>operator&gt;&gt;</code>:</p>
<blockquote>
  <pre>template &lt;class charT, class traits&gt;
  std::basic_istream&lt;charT, traits&gt;&amp;
    operator&gt;&gt;(std::basic_istream&lt;charT, traits&gt;&amp; is, const <i><b><code>implementation-type3</code></b></i>&amp; proxy);</pre>
<p><i>Effects:</i> <ins>Using basic_istream::operator&gt;&gt; ([istream::extractors]), 
which may throw <code>ios_base::failure</code> ([ios::failure]),</ins> extracts 
characters from <code>os</code>:</p>
  <ul>
    <li>If the first character extracted is equal to delim, as determined by
    <code>operator==</code>, then:<ul>
      <li>Turn off the <code>skipws</code> flag.</li>
      <li><code>string.clear()</code></li>
      <li dir="ltr">
      <p dir="ltr">Until an unescaped <code>delim</code> character is reached or <code>
      is.not_good()</code>, extract 
      characters from <code>os</code> and append them to <code>string</code>, 
      except that if an <code>escape</code> is reached, ignore it and append the 
      next character to <code>string</code>.</li>
      <li>Discard the final <code>delim</code> character.</li>
      <li>Restore the <code>skipws</code> flag to its original value.</li>
    </ul>
    </li>
    <li>Otherwise, <code>os &gt;&gt; string</code>.</li>
  </ul>
<p><i>Remarks:</i> <code>string</code>, <code>escape</code>, and <code>delim</code> 
have the type and value of the corresponding arguments of the call to the <code>
quoted</code> function that constructed <code>proxy</code>.</p>
<p><i>Returns:</i> <code>is</code>. </p>
</blockquote>
<h3>Non-member functions</h3>
  <pre>template &lt;class charT, class traits, class Allocator&gt;
<i>unspecified</i> quoted(const std::basic_string&lt;charT, traits, Allocator&gt;&amp; s,
                            charT delim='&quot;', charT escape='\\');
template &lt;class charT, class traits, class Allocator&gt;
<i>unspecified</i> quoted(const charT* s,
                            charT delim='&quot;', charT escape='\\');
template &lt;class charT, class traits, class Allocator&gt;
<i>unspecified</i> quoted(std::basic_string&lt;charT, traits, Allocator&gt;&amp; s,
                            charT delim='&quot;', charT escape='\\');</pre>
  <blockquote>
    <p><i>Returns:</i> An object of an implementation supplied type that meets 
    the requirements of [quoted.imp].</p>
    <p dir="ltr"><i>Remarks:</i> The returned object encapsulates the <code>s</code>,
    <code>delim</code>, and <code>escape</code> argument values.</p>
  </blockquote>
  <h2>Acknowledgements</h2>
<p>The <code>quoted()</code> stream manipulators emerged from discussions on the 
Boost developers mailing list. Participants included Beman Dawes, Rob Stewart, 
Alexander Lamaison, Eric Niebler, Vicente Botet, Andrey Semashev, Phil Richards, 
and Rob Murray. Eric Niebler's suggestions provided the basis for the name and 
form of the templates. </p>
<hr>

</body>
</html>